[
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "941dc431-ac00-4dd1-b675-73f19e7eb452",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC001-Email Magic Link Authentication Success",
    "description": "Verify that a user can successfully authenticate using an email magic link and is redirected to the dashboard.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_email_magic_link_authentication_success():\n    session = requests.Session()\n    try:\n        # Step 1: Access dashboard without authentication: expect redirect to login (302)\n        dashboard_response_before_auth = session.get(f\"{BASE_URL}/\", timeout=TIMEOUT, allow_redirects=False)\n        assert dashboard_response_before_auth.status_code == 302, \"Expected redirect to login before authentication\"\n\n        # Step 2: Simulate OAuth callback with code query parameter\n        # According to PRD, GET /auth/callback?code=string returns 302 redirect to dashboard\n        code = \"testcode\"\n        auth_callback_response = session.get(f\"{BASE_URL}/auth/callback\", params={\"code\": code}, timeout=TIMEOUT, allow_redirects=False)\n        assert auth_callback_response.status_code == 302, \"Expected redirect to dashboard after auth callback\"\n\n        # Step 3: Access dashboard after authentication callback\n        dashboard_response = session.get(f\"{BASE_URL}/\", timeout=TIMEOUT)\n        assert dashboard_response.status_code == 200, \"Dashboard not accessible after authentication\"\n        # The content should contain dashboard info - user groups, etc. The PRD says content-type text/html with string body\n        assert \"dashboard\" in dashboard_response.text.lower(), \"Dashboard content does not appear correct\"\n    finally:\n        session.close()\n\n\ntest_email_magic_link_authentication_success()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 11, in test_email_magic_link_authentication_success\nAssertionError: Expected redirect to login before authentication\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.594Z",
    "modified": "2025-09-05T09:47:13.432Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "a52f631b-738c-43e8-bb33-8deec18e7292",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC002-Google OAuth Authentication Success",
    "description": "Ensure user can authenticate using Google OAuth and successfully arrive at their dashboard.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_google_oauth_authentication_success():\n    \"\"\"\n    Ensure user can authenticate using Google OAuth and arrive at dashboard.\n    The flow is simulated by invoking the OAuth callback endpoint with a sample valid code.\n    Then verify redirection to dashboard (HTTP 302 with Location header).\n    Finally, access dashboard page to confirm user groups are displayed (HTTP 200).\n    \"\"\"\n    # NOTE: In real scenario, obtaining a valid 'code' from Google OAuth flow would be dynamic.\n    # For this test, assume 'valid_oauth_code' is a placeholder for a valid OAuth code.\n    valid_oauth_code = \"sample_valid_oauth_code\"\n\n    session = requests.Session()\n\n    try:\n        # Step 1: Invoke OAuth callback endpoint with code parameter\n        callback_url = f\"{BASE_URL}/auth/callback\"\n        params = {\"code\": valid_oauth_code}\n        response = session.get(callback_url, params=params, allow_redirects=False, timeout=TIMEOUT)\n        \n        # Expect 302 redirect to dashboard (according to PRD)\n        assert response.status_code == 302, f\"Expected 302 redirect, got {response.status_code}\"\n        location = response.headers.get(\"Location\")\n        assert location and location.endswith(\"/\"), f\"Expected redirect to dashboard, got: {location}\"\n\n        # Step 2: Follow redirection to dashboard page\n        dashboard_url = f\"{BASE_URL}/\"\n        dashboard_response = session.get(dashboard_url, timeout=TIMEOUT)\n\n        # Dashboard should respond with 200 OK and HTML content\n        assert dashboard_response.status_code == 200, f\"Expected 200 OK on dashboard, got {dashboard_response.status_code}\"\n        content_type = dashboard_response.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type.lower(), f\"Expected HTML content type, got {content_type}\"\n\n        # Basic content validation: dashboard likely contains certain keywords\n        html_text = dashboard_response.text.lower()\n        assert \"dashboard\" in html_text or \"groups\" in html_text, \"Dashboard page does not contain expected content\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    finally:\n        session.close()\n\ntest_google_oauth_authentication_success()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 26, in test_google_oauth_authentication_success\nAssertionError: Expected 302 redirect, got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.600Z",
    "modified": "2025-09-05T09:46:53.446Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "f22266fe-f233-4153-97a7-613345a51d5d",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC003-OAuth Callback Redirect Handling",
    "description": "Verify the OAuth callback endpoint correctly processes the authentication code and redirects users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_oauth_callback_redirect_handling():\n    # A valid OAuth authentication code for testing purpose (in reality this would be obtained dynamically)\n    valid_auth_code = \"valid_test_auth_code_123456\"\n\n    # Construct the request URL with the authentication code\n    url = f\"{BASE_URL}/auth/callback\"\n    params = {\"code\": valid_auth_code}\n\n    try:\n        response = requests.get(url, params=params, allow_redirects=False, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to OAuth callback endpoint failed: {e}\"\n\n    # Assert that a redirect (302) response is received\n    assert response.status_code == 302, f\"Expected 302 redirect, got {response.status_code}\"\n\n    # Validate the Location header for redirection to dashboard or expected destination\n    redirect_location = response.headers.get(\"Location\")\n    assert redirect_location is not None, \"Redirect location header missing\"\n    assert redirect_location.endswith(\"/\"), f\"Redirect location expected to end with '/', got: {redirect_location}\"\n    # Typically, OAuth callback after successful login redirects to dashboard '/' or '/dashboard'\n    assert redirect_location in [\"/\", \"/dashboard\"], f\"Unexpected redirect location: {redirect_location}\"\n\ntest_oauth_callback_redirect_handling()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 29, in <module>\n  File \"<string>\", line 20, in test_oauth_callback_redirect_handling\nAssertionError: Expected 302 redirect, got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.605Z",
    "modified": "2025-09-05T09:46:53.444Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "b57a1d52-e039-4e87-b2e4-83661d382fcb",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC004-Dashboard Loads User Groups",
    "description": "Verify dashboard loads and correctly displays all groups the user is a member of.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_dashboard_loads_user_groups():\n    session = requests.Session()\n    try:\n        auth_token = \"Bearer test_valid_user_token\"\n        headers = {\n            \"Authorization\": auth_token\n        }\n        dashboard_resp = session.get(f\"{BASE_URL}/\", headers=headers, timeout=TIMEOUT, allow_redirects=False)\n        assert dashboard_resp.status_code == 200, f\"Expected 200 OK from dashboard, got {dashboard_resp.status_code}\"\n        content = dashboard_resp.text\n        assert len(content.strip()) > 0, \"Dashboard page content is empty\"\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n    finally:\n        session.close()\n\ntest_dashboard_loads_user_groups()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.610Z",
    "modified": "2025-09-05T09:47:03.730Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "658d5c79-95b6-438c-a514-f45cd0f00537",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC005-Dashboard Redirects Unauthorized Users",
    "description": "Verify that unauthenticated users navigating to the dashboard are redirected to the login page.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_dashboard_redirects_unauthorized_users():\n    \"\"\"\n    Verify that unauthenticated users navigating to the dashboard are redirected to the login page.\n    \"\"\"\n    dashboard_url = f\"{BASE_URL}/\"\n    try:\n        response = requests.get(dashboard_url, allow_redirects=False, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to dashboard failed with exception: {e}\"\n\n    # Expecting a redirect (302) status code to login page for unauthorized user\n    assert response.status_code == 302, f\"Expected 302 redirect, got {response.status_code}\"\n\n    # The Location header should point to the login page\n    location = response.headers.get(\"Location\") or response.headers.get(\"location\")\n    assert location is not None, \"Redirect response missing 'Location' header\"\n    assert \"/auth/login\" in location or \"/login\" in location, f\"Redirect location expected to be login page, got: {location}\"\n\ntest_dashboard_redirects_unauthorized_users()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 24, in <module>\n  File \"<string>\", line 17, in test_dashboard_redirects_unauthorized_users\nAssertionError: Expected 302 redirect, got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.615Z",
    "modified": "2025-09-05T09:46:49.525Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "0a8fbbf0-2f4a-4d71-936b-d6350ed3ecf1",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC006-Create New Expense Splitting Group",
    "description": "Ensure that a user can successfully create a new expense splitting group with valid input.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Removed authentication due to no /auth/login endpoint\n\ndef test_create_new_expense_splitting_group():\n    group_id = None\n    group_name = f\"Test Group {uuid.uuid4()}\"\n    payload = {\n        \"name\": group_name,\n        \"description\": \"Group created by automated test for expense splitting.\"\n    }\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        # Create new expense splitting group\n        create_resp = requests.post(\n            f\"{BASE_URL}/groups\",\n            headers=headers,\n            json=payload,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Expected 201 Created, got {create_resp.status_code}\"\n        create_resp_json = create_resp.json()\n        group_id = create_resp_json.get(\"id\")\n        assert group_id, \"Response JSON does not include 'id' of the created group\"\n        assert create_resp_json.get(\"name\") == group_name, \"Group name in response does not match request\"\n\n        # Retrieve the group to verify it was created successfully\n        get_resp = requests.get(\n            f\"{BASE_URL}/groups/{group_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Expected 200 OK for group retrieval, got {get_resp.status_code}\"\n        group_html = get_resp.text\n        assert group_name in group_html, \"Group name not found in group details page\"\n\n    finally:\n        # Cleanup: delete the created group to maintain test environment\n        if group_id:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/groups/{group_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                # Accept 200 OK or 204 No Content as successful deletion\n                assert del_resp.status_code in (200, 204), f\"Failed to delete test group, status code {del_resp.status_code}\"\n            except Exception as cleanup_err:\n                print(f\"Warning: could not delete test group {group_id}. Exception: {cleanup_err}\")\n\ntest_create_new_expense_splitting_group()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 27, in test_create_new_expense_splitting_group\nAssertionError: Expected 201 Created, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.619Z",
    "modified": "2025-09-05T09:47:13.435Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "2096e775-3295-4d18-8480-cf6ef258fcca",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC007-Access Specific Group Details",
    "description": "Verify that a group member can access the group's detail page without errors.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef authenticate_user():\n    \"\"\"\n    Dummy authentication function.\n    Replace this with actual authentication to get a valid session or token.\n    For this test, assume session cookie or auth token is acquired here.\n    \"\"\"\n    # Example: Login with email magic link or Google OAuth would be here.\n    # For simplicity, we simulate login by sending credentials to a hypothetical login endpoint\n    # and returning a session cookie or auth token.\n\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"email\": \"testuser@example.com\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        # Assume the response sets a session cookie or returns a token\n        # Here we simulate retrieval of a cookie called 'sessionid'\n        cookies = resp.cookies\n        token = resp.json().get(\"access_token\")  # or get cookie from resp.cookies\n        return cookies, token\n    except Exception:\n        # If no real auth is implemented, return empty cookies and None token\n        return None, None\n\ndef create_group(auth_cookies, auth_token):\n    url = f\"{BASE_URL}/groups\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    if auth_token:\n        headers[\"Authorization\"] = f\"Bearer {auth_token}\"\n\n    payload = {\n        \"name\": \"Test Group for TC007\"\n    }\n    try:\n        resp = requests.post(url, json=payload, headers=headers, cookies=auth_cookies, timeout=TIMEOUT)\n        resp.raise_for_status()\n        # Expect response json or header to contain the created group ID\n        json_resp = resp.json()\n        group_id = json_resp.get(\"id\")\n        if not group_id:\n            raise ValueError(\"Group ID not returned from create group API\")\n        return group_id\n    except RequestException as e:\n        raise RuntimeError(f\"Failed to create group: {e}\")\n\ndef delete_group(group_id, auth_cookies, auth_token):\n    url = f\"{BASE_URL}/groups/{group_id}\"\n    headers = {}\n    if auth_token:\n        headers[\"Authorization\"] = f\"Bearer {auth_token}\"\n    try:\n        resp = requests.delete(url, headers=headers, cookies=auth_cookies, timeout=TIMEOUT)\n        # Deleting might return 204 No Content or 200 OK\n        if resp.status_code not in (200, 204):\n            raise RuntimeError(f\"Failed to delete group with status code {resp.status_code}\")\n    except RequestException as e:\n        raise RuntimeError(f\"Failed to delete group: {e}\")\n\ndef test_access_specific_group_details():\n    # Authenticate and get cookies or token\n    auth_cookies, auth_token = authenticate_user()\n    if auth_cookies is None and auth_token is None:\n        # If no real authentication, skip this test because group access requires auth\n        raise RuntimeError(\"Authentication failed or not implemented\")\n\n    group_id = None\n    headers = {}\n    if auth_token:\n        headers[\"Authorization\"] = f\"Bearer {auth_token}\"\n\n    try:\n        # Create a group to access\n        group_id = create_group(auth_cookies, auth_token)\n\n        # Access the group's detail page\n        url = f\"{BASE_URL}/groups/{group_id}\"\n        resp = requests.get(url, headers=headers, cookies=auth_cookies, timeout=TIMEOUT)\n\n        assert resp.status_code == 200, f\"Expected status code 200, got {resp.status_code}\"\n        content_type = resp.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type, f\"Expected 'text/html' content, got {content_type}\"\n        assert resp.text and len(resp.text) > 0, \"Group details page response body is empty\"\n\n    finally:\n        # Cleanup - delete the created group if created\n        if group_id:\n            try:\n                delete_group(group_id, auth_cookies, auth_token)\n            except Exception:\n                pass  # Ignore cleanup errors\n\ntest_access_specific_group_details()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 77, in test_access_specific_group_details\nRuntimeError: Authentication failed or not implemented\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.624Z",
    "modified": "2025-09-05T09:46:58.985Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "46af615b-5bbf-45e2-bffa-f818db1c43e3",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC008-Prevent Unauthorized Access to Group Balances",
    "description": "Ensure users who are not members of a group cannot access its balance details and receive a 403 error.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_prevent_unauthorized_access_to_group_balances():\n    # This test will:\n    # 1. Register and authenticate two users: one group member and one non-member.\n    # 2. The member user creates a group.\n    # 3. The non-member user tries to access the group's balances endpoint.\n    # 4. The request should return HTTP 403 Forbidden for the non-member user.\n\n    # For the purposes of this test, assume the API has endpoints to:\n    # - register/login users with email magic link or similar\n    # - create groups (POST /groups)\n    # - retrieve balances (GET /groups/{groupId}/balances)\n    # Since no concrete auth API details are given beyond OAuth callback,\n    # we'll simulate login by obtaining authentication tokens via a dummy login endpoint.\n\n    # We'll simulate login by calling a hypothetical login endpoint that returns an auth token.\n    # If unavailable, a bearer token or cookie for authentication should be set.\n    # Since not specified, we'll assume bearer token auth with Authorization header.\n\n    # Helper function for user login simulation:\n    def login_user(email):\n        resp = requests.post(f\"{BASE_URL}/auth/login\", json={\"email\": email}, timeout=TIMEOUT)\n        resp.raise_for_status()\n        # Expecting response JSON with access_token\n        token = resp.json().get(\"access_token\")\n        if not token:\n            raise ValueError(\"Login failed to return access token\")\n        return token\n\n    # Helper function to create group\n    def create_group(token, group_name=\"Test Group Unauthorized Access\"):\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n        payload = {\"name\": group_name}\n        resp = requests.post(f\"{BASE_URL}/groups\", json=payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        group = resp.json()\n        group_id = group.get(\"id\")\n        if not group_id:\n            raise ValueError(\"Group creation did not return group id\")\n        return group_id\n\n    # LOGIN: create two users\n    user_member_email = \"member_testuser@example.com\"\n    user_nonmember_email = \"nonmember_testuser@example.com\"\n\n    # Login users and get their tokens\n    token_member = login_user(user_member_email)\n    token_nonmember = login_user(user_nonmember_email)\n\n    # Create a group with member user\n    group_id = None\n    try:\n        group_id = create_group(token_member)\n\n        # Non-member tries to access balances of the group\n        headers_nonmember = {\"Authorization\": f\"Bearer {token_nonmember}\"}\n        url = f\"{BASE_URL}/groups/{group_id}/balances\"\n        response = requests.get(url, headers=headers_nonmember, timeout=TIMEOUT)\n\n        # Assert forbidden status code 403\n        assert response.status_code == 403, f\"Expected 403 Forbidden, got {response.status_code}\"\n\n    finally:\n        # Cleanup: delete the group with member token if group_id exists\n        if group_id:\n            headers_member = {\"Authorization\": f\"Bearer {token_member}\"}\n            try:\n                requests.delete(f\"{BASE_URL}/groups/{group_id}\", headers=headers_member, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_prevent_unauthorized_access_to_group_balances()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 76, in <module>\n  File \"<string>\", line 51, in test_prevent_unauthorized_access_to_group_balances\n  File \"<string>\", line 27, in login_user\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.629Z",
    "modified": "2025-09-05T09:47:03.768Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "91b6c97b-d6ad-4121-a13f-51e89b5a52c4",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC009-Balance Calculations Accuracy",
    "description": "Verify that the balance calculation correctly computes owed amounts between group members.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef authenticate_test_user():\n    # For the sake of this test, assume there's an endpoint to login test user and get a session cookie or token.\n    # Since authentication details are not provided, simulate authentication by returning a session with auth headers or cookies.\n    # Replace with actual login flow if available.\n    session = requests.Session()\n    # Simulated auth: set a header or cookie here if needed.\n    # For example: session.headers.update({\"Authorization\": \"Bearer <token>\"})\n    return session\n\ndef create_group(session, group_name):\n    url = f\"{BASE_URL}/groups\"\n    payload = {\n        \"name\": group_name,\n        \"description\": \"Test group for balance calculation\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    resp = session.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    group_data = resp.json()\n    return group_data[\"id\"]\n\ndef delete_group(session, group_id):\n    url = f\"{BASE_URL}/groups/{group_id}\"\n    resp = session.delete(url, timeout=TIMEOUT)\n    # Deletion might return 204 No Content or 200 OK, or 404 if already deleted\n    if resp.status_code not in (200, 204, 404):\n        resp.raise_for_status()\n\ndef add_member_to_group(session, group_id, member_email):\n    url = f\"{BASE_URL}/groups/{group_id}/members\"\n    payload = {\n        \"email\": member_email\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = session.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    member_data = resp.json()\n    return member_data[\"id\"]\n\ndef add_expense(session, group_id, paid_by, amount, description, split_between):\n    url = f\"{BASE_URL}/groups/{group_id}/expenses\"\n    payload = {\n        \"paid_by\": paid_by,\n        \"amount\": amount,\n        \"description\": description,\n        \"split_between\": split_between\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n    resp = session.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    expense_data = resp.json()\n    return expense_data[\"id\"]\n\ndef get_group_balances(session, group_id):\n    url = f\"{BASE_URL}/groups/{group_id}/balances\"\n    resp = session.get(url, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef test_balance_calculations_accuracy():\n    session = authenticate_test_user()\n    group_id = None\n    members = []\n    try:\n        group_id = create_group(session, f\"TestGroup-{uuid.uuid4()}\")\n        assert group_id, \"Failed to create group\"\n\n        # Add members to the group\n        member_emails = [f\"user1_{uuid.uuid4()}@example.com\", f\"user2_{uuid.uuid4()}@example.com\", f\"user3_{uuid.uuid4()}@example.com\"]\n        for email in member_emails:\n            member_id = add_member_to_group(session, group_id, email)\n            assert member_id, f\"Failed to add member {email}\"\n            members.append({\"email\": email, \"id\": member_id})\n\n        # Add expenses:\n        # User1 pays $60 split equally among all three\n        add_expense(session, group_id, members[0][\"email\"], 60, \"Dinner\", member_emails)\n        # User2 pays $30 split between user2 and user3\n        add_expense(session, group_id, members[1][\"email\"], 30, \"Taxi\", member_emails[1:3])\n        # User3 pays $15 for user1 and user3\n        add_expense(session, group_id, members[2][\"email\"], 15, \"Snacks\", [member_emails[0], member_emails[2]])\n\n        # Retrieve balances\n        balances = get_group_balances(session, group_id)\n        assert isinstance(balances, dict), \"Balances response is not a dict\"\n        # balances expected example schema:\n        # {\n        #   \"owed\": [\n        #       {\"from\": \"user_email\", \"to\": \"user_email\", \"amount\": float},\n        #       ...\n        #   ]\n        # }\n\n        assert \"owed\" in balances, \"'owed' key missing in balances response\"\n        owed_list = balances[\"owed\"]\n        assert isinstance(owed_list, list), \"'owed' should be a list\"\n\n        # Calculate expected balances manually:\n        # Expenses:\n        # Dinner: $60 by user1 split 3 ways = each owes 20\n        # Taxi: $30 by user2 split 2 ways (user2,user3) = each owes 15\n        # Snacks: $15 by user3 split 2 ways (user1,user3) = each owes 7.5\n\n        # Amounts paid:\n        # user1 paid 60\n        # user2 paid 30\n        # user3 paid 15\n\n        # Amounts owed:\n        # user1 owes: dinner(20) + taxi(?) + snacks(7.5)\n        # user2 owes: dinner(20) + taxi(15) + snacks(?)\n        # user3 owes: dinner(20) + taxi(15) + snacks(7.5)\n\n        # Calculate net balances per user:\n        # user1 owes: dinner 20 (to self?), snacks 7.5 (split - user1 owes?), taxi costs not including user1\n        # Actually, user1 is among snacks payers(2 people). User1 owes 7.5 to user3.\n        # user2 owes: dinner 20, taxi 15 (user2 paid taxi, so owe none?), snacks none (user2 not in snacks)\n        # user3 owes: dinner 20, taxi 15, snacks 7.5 paid\n        # But better to calculate net amount per user:\n\n        # Total shares for each user:\n        shares = {\n            member_emails[0]: 20 + 0 + 7.5,  # user1\n            member_emails[1]: 20 + 15 + 0,   # user2\n            member_emails[2]: 20 + 15 + 7.5  # user3\n        }\n        # Paid amounts:\n        paid = {\n            member_emails[0]: 60,\n            member_emails[1]: 30,\n            member_emails[2]: 15\n        }\n        # Net = paid - shares\n        net_balances = {user: round(paid[user] - shares[user], 2) for user in shares}\n\n        # Positive net => user is owed money\n        # Negative net => user owes money\n\n        # Prepare a map for quick lookup of who owes who from balances response\n        # The \"owed\" array should confirm these balances, e.g. user who owes pays to who is owed.\n        # For simplicity check sum of all amounts equals zero and check balances match net_balances sums\n\n        total_owed_amount = sum(item[\"amount\"] for item in owed_list)\n        # floating point slight tolerance\n        assert abs(total_owed_amount) < 0.01, \"Total owed amounts do not sum to zero, invalid balances\"\n\n        # We can check each user net balance sum from owed list:\n        owed_from = {}\n        owed_to = {}\n        for txn in owed_list:\n            frm = txn.get(\"from\")\n            to = txn.get(\"to\")\n            amt = txn.get(\"amount\")\n            assert isinstance(frm, str) and isinstance(to, str), \"Invalid 'from' or 'to' fields in balances\"\n            assert isinstance(amt, (int, float)) and amt >= 0, \"Invalid amount in balances\"\n            owed_from[frm] = owed_from.get(frm, 0) + amt\n            owed_to[to] = owed_to.get(to, 0) + amt\n\n        # Calculate user net from owed_from - owed_to\n        user_net = {}\n        all_users = set(list(owed_from.keys()) + list(owed_to.keys()))\n        for user in all_users:\n            out_amt = owed_from.get(user, 0)\n            in_amt = owed_to.get(user, 0)\n            user_net[user] = round(in_amt - out_amt, 2)\n\n        # user_net should match net_balances computed above, for the users in the group\n        for user_email in net_balances:\n            expected = net_balances[user_email]\n            actual = user_net.get(user_email, 0)\n            assert abs(actual - expected) < 0.05, f\"Balance mismatch for user {user_email}: expected {expected}, got {actual}\"\n\n    finally:\n        if group_id:\n            try:\n                delete_group(session, group_id)\n            except Exception:\n                pass\n\ntest_balance_calculations_accuracy()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 73, in test_balance_calculations_accuracy\n  File \"<string>\", line 26, in create_group\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/groups\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.634Z",
    "modified": "2025-09-05T09:47:03.732Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "f71c6bed-9968-429e-950b-88b8caa13e6e",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC010-UI Component Rendering Consistency",
    "description": "Verify that reusable UI components such as buttons, cards, inputs, and labels render correctly across multiple pages.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_ui_component_rendering_consistency():\n    \"\"\"\n    Verify that reusable UI components such as buttons, cards, inputs, and labels render correctly across multiple pages.\n    This test will check main pages in SplitEasy app for presence of expected UI components' HTML markers.\n    \"\"\"\n\n    # Pages to check for UI components consistency\n    pages = [\n        \"/\",  # Dashboard page (user groups and main UI)\n        \"/groups/sample-group-id\",  # Group details page (replace sample-group-id with existing or dummy)\n        \"/groups/sample-group-id/balances\",  # Group balances page\n        \"/auth/callback?code=dummycode\"  # OAuth callback page (though it redirects, check content if any)\n    ]\n\n    # The test focuses on UI component rendering presence in HTML response strings.\n\n    component_markers = {\n        \"button\": ['<button', 'class=\"btn\"', 'class=\"Button\"'],\n        \"card\": ['class=\"card\"', 'class=\"bg-white\"'],\n        \"input\": ['<input', 'class=\"input\"', 'class=\"Input\"'],\n        \"label\": ['<label', 'class=\"label\"', 'class=\"Label\"']\n    }\n\n    session = requests.Session()\n\n    for page in pages:\n        try:\n            response = session.get(f\"{BASE_URL}{page}\", timeout=TIMEOUT, allow_redirects=True)\n        except requests.RequestException as e:\n            assert False, f\"Request to {page} failed: {e}\"\n\n        # If redirected to login page for authenticated pages, the test fails as UI components cannot be checked properly\n        if response.url.endswith(\"/login\"):\n            assert False, f\"Unauthorized redirect to login detected when accessing {page}\"\n\n        # Check response status code\n        assert response.status_code == 200, f\"Unexpected status code {response.status_code} on page {page}\"\n\n        content = response.text\n\n        # Check for each UI component's presence via at least one marker string in content\n        for component_name, markers in component_markers.items():\n            found = any(marker in content for marker in markers)\n            assert found, f\"{component_name} UI component not found on page {page}\"\n\ntest_ui_component_rendering_consistency()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 49, in test_ui_component_rendering_consistency\nAssertionError: card UI component not found on page /\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.638Z",
    "modified": "2025-09-05T09:47:31.459Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "fe1956b6-4312-4ff4-9e9a-ddb5f0410b61",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC011-Form Validation on Add Expense and Group Creation",
    "description": "Verify that forms for adding expenses and creating groups have proper validation, including required fields and input formats.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_form_validation_add_expense_and_group_creation():\n    session = requests.Session()\n\n    # Helper function to authenticate user - assuming a test user and token exist\n    # As PRD does not provide auth endpoint details for token, skip auth here but include placeholders\n    headers = {\n        \"Content-Type\": \"application/json\",\n        # \"Authorization\": \"Bearer <token>\",  # Add if needed\n    }\n\n    # 1. Test Group Creation Validation\n\n    # Required field missing: empty payload\n    group_creation_payloads = [\n        {},  # empty payload\n        {\"name\": \"\"},  # empty string required field\n        {\"name\": \"Valid Group\", \"description\": 123},  # wrong type\n    ]\n\n    for payload in group_creation_payloads:\n        resp = session.post(f\"{BASE_URL}/groups\", json=payload, headers=headers, timeout=TIMEOUT)\n        # Expecting 400 Bad Request or similar validation error status code for invalid input\n        assert resp.status_code in (400, 422), f\"Expected validation error status for payload {payload}, got {resp.status_code}\"\n        json_resp = None\n        try:\n            json_resp = resp.json()\n        except Exception:\n            pass\n        assert json_resp is None or \"error\" in json_resp or \"message\" in json_resp, \"Expected error message in response for invalid group creation\"\n\n    # 2. Test Add Expense Validation\n\n    # First, create a valid group to test adding expense within it\n    valid_group_payload = {\"name\": \"Test Group for Expense Validation\"}\n    create_group_resp = session.post(f\"{BASE_URL}/groups\", json=valid_group_payload, headers=headers, timeout=TIMEOUT)\n    assert create_group_resp.status_code == 201 or create_group_resp.status_code == 200, \"Failed to create group for expense tests\"\n    try:\n        group_data = create_group_resp.json()\n        group_id = group_data.get(\"id\") or group_data.get(\"groupId\")\n        assert group_id, \"Group ID not returned in creation response\"\n    except Exception as e:\n        raise AssertionError(\"Failed to parse created group response\") from e\n\n    try:\n        # Test invalid expense payloads (missing required fields, wrong formats)\n        expense_payloads = [\n            {},  # empty payload\n            {\"amount\": \"\", \"description\": \"Dinner\"},  # empty amount\n            {\"amount\": -10, \"description\": \"Dinner\"},  # negative amount\n            {\"amount\": 25.50},  # missing description\n            {\"amount\": 25.50, \"description\": \"\"},  # empty description\n            {\"amount\": \"twenty\", \"description\": \"Dinner\"},  # amount string instead of number\n            {\"amount\": 10, \"description\": \"Dinner\", \"date\": \"invalid-date-format\"},  # invalid date format\n        ]\n\n        for expense_payload in expense_payloads:\n            resp = session.post(f\"{BASE_URL}/groups/{group_id}/expenses\", json=expense_payload, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code in (400, 422), f\"Expected validation error status for expense payload: {expense_payload}, got {resp.status_code}\"\n            try:\n                err_json = resp.json()\n                assert \"error\" in err_json or \"message\" in err_json, \"Expected error message in response for invalid expense data\"\n            except Exception:\n                pass\n    finally:\n        # Cleanup - delete the created group to avoid pollution\n        session.delete(f\"{BASE_URL}/groups/{group_id}\", headers=headers, timeout=TIMEOUT)\n\ntest_form_validation_add_expense_and_group_creation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 28, in test_form_validation_add_expense_and_group_creation\nAssertionError: Expected validation error status for payload {}, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.644Z",
    "modified": "2025-09-05T09:47:15.896Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "bc1f59eb-ae32-46e8-8586-d8067350d6ea",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC012-Error Page Displays on Authentication Failure",
    "description": "Verify the error handling page displays appropriately when authentication fails or an invalid login attempt is made.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_error_page_displays_on_auth_failure():\n    \"\"\"\n    Verify the error handling page displays appropriately when authentication fails or\n    an invalid login attempt is made.\n    \"\"\"\n    error_page_url = f\"{BASE_URL}/auth/error\"\n    # Simulate invalid login attempt by accessing a protected resource without valid auth\n    try:\n        # Attempt to access dashboard without authentication\n        response = requests.get(f\"{BASE_URL}/\", timeout=TIMEOUT, allow_redirects=False)\n        # Expected behavior: redirect to login or error page on unauthorized access\n        assert response.status_code in (200, 302, 401, 403), \\\n            f\"Unexpected status code for unauthenticated access to dashboard: {response.status_code}\"\n\n        if response.status_code == 200:\n            # Check for indication of login or error content\n            assert (\"login\" in response.text.lower() or \"error\" in response.text.lower() or \"authentication\" in response.text.lower()), \\\n                \"Error or login content not found on dashboard page for auth failure\"\n\n        # If redirected, follow to check error page presence\n        elif response.status_code == 302:\n            redirect_location = response.headers.get(\"Location\", \"\")\n            # Visit redirected location\n            redirect_response = requests.get(f\"{BASE_URL}{redirect_location}\", timeout=TIMEOUT)\n            # Check for indication of error handling/login page content\n            assert redirect_response.status_code == 200, \\\n                f\"Redirect location did not load successfully, status: {redirect_response.status_code}\"\n            assert (\"login\" in redirect_response.text.lower()\n                    or \"error\" in redirect_response.text.lower()\n                    or \"authentication\" in redirect_response.text.lower()), \\\n                \"Error or login content not found on redirect page for auth failure\"\n\n        # Additionally, directly test OAuth callback with invalid code param for error handling\n        invalid_code = \"invalid_auth_code_123\"\n        oauth_response = requests.get(f\"{BASE_URL}/auth/callback?code={invalid_code}\",\n                                      allow_redirects=False, timeout=TIMEOUT)\n        # The invalid code should NOT redirect to dashboard (302), possibly show error or 401/403\n        assert oauth_response.status_code != 302, \"Invalid OAuth code unexpectedly redirected to dashboard\"\n        # If server returns a page, check for error indications\n        if oauth_response.status_code == 200:\n            assert (\"error\" in oauth_response.text.lower()\n                    or \"invalid\" in oauth_response.text.lower()\n                    or \"failed\" in oauth_response.text.lower()), \\\n                \"Expected error indication not found in OAuth callback response for invalid code\"\n        else:\n            # For 4xx or 5xx status codes just validate these are authentication failure related\n            assert oauth_response.status_code in (400, 401, 403, 404), \\\n                f\"Unexpected status code for invalid OAuth callback: {oauth_response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed unexpectedly: {e}\"\n\ntest_error_page_displays_on_auth_failure()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.649Z",
    "modified": "2025-09-05T09:47:28.037Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "1d73b6be-33bf-40f2-9819-12af5a081ef8",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC013-UI Consistency During Navigation and Authentication States",
    "description": "Ensure UI components maintain visual and functional consistency during login transitions, dashboard loading, and group navigation.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_ui_consistency_during_navigation_and_authentication():\n    session = requests.Session()\n    try:\n        # Step 1: Access login page (simulate visiting login page)\n        login_response = session.get(f\"{BASE_URL}/auth/login\", timeout=TIMEOUT)\n        assert login_response.status_code == 200\n        assert \"login\" in login_response.text.lower()  # Check page content contains login form hints\n\n        # Step 2: Simulate login via email magic link\n        dummy_oauth_code = \"dummy_code_for_testing\"\n\n        # OAuth callback to trigger login redirect\n        callback_response = session.get(f\"{BASE_URL}/auth/callback\", params={\"code\": dummy_oauth_code}, allow_redirects=False, timeout=TIMEOUT)\n        # Expecting a 302 redirect to dashboard on success\n        assert callback_response.status_code == 302\n        assert \"Location\" in callback_response.headers\n        redirect_location = callback_response.headers[\"Location\"]\n        # PRD specifies redirect to dashboard (root path '/') after successful authentication\n        assert redirect_location == \"/\"\n\n        # Step 3: Follow redirect to dashboard\n        dashboard_url = BASE_URL + redirect_location\n        dashboard_response = session.get(dashboard_url, timeout=TIMEOUT)\n        assert dashboard_response.status_code == 200\n        assert \"groups\" in dashboard_response.text.lower() or \"dashboard\" in dashboard_response.text.lower()\n\n        # Step 4: Assume user has at least one group; parse group IDs from dashboard page.\n        # Since HTML parsing is required (not detailed), we search for group URL pattern \"/groups/{groupId}\"\n        import re\n        group_ids = re.findall(r'/groups/([\\w-]+)', dashboard_response.text)\n        assert group_ids, \"No groups found on dashboard for navigating\"\n\n        # Use the first group ID for navigation\n        group_id = group_ids[0]\n\n        # Step 5: Access group details page\n        group_response = session.get(f\"{BASE_URL}/groups/{group_id}\", timeout=TIMEOUT)\n        assert group_response.status_code == 200\n        assert \"group\" in group_response.text.lower()\n\n        # Step 6: Access group balances page\n        balances_response = session.get(f\"{BASE_URL}/groups/{group_id}/balances\", timeout=TIMEOUT)\n        assert balances_response.status_code == 200\n        assert \"balance\" in balances_response.text.lower()\n\n        # Step 7: Validate consistent UI components by checking repeated presence of UI keywords or markers\n        # These are placeholders - in real UI test, we would check React components or CSS classes\n        ui_markers = [\"button\", \"card\", \"input\", \"label\"]\n        for marker in ui_markers:\n            assert marker in dashboard_response.text.lower()\n            assert marker in group_response.text.lower()\n            assert marker in balances_response.text.lower()\n    except RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_ui_consistency_during_navigation_and_authentication()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 12, in test_ui_consistency_during_navigation_and_authentication\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.654Z",
    "modified": "2025-09-05T09:47:46.718Z"
  },
  {
    "projectId": "43357de9-d2fe-4463-b220-1a5b34be7ec9",
    "testId": "9efef340-f678-4f73-a729-0469b80c45dc",
    "userId": "3448f448-5051-703e-9e49-0dd803a8478b",
    "title": "TC014-Form Reset Behavior After Successful Submission",
    "description": "Verify that forms for creating groups and adding expenses reset properly after successful submission.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Assuming authentication is required, include auth token here if available.\n    # \"Authorization\": \"Bearer <token>\"\n}\n\ndef test_form_reset_behavior_after_successful_submission():\n    group_id = None\n    expense_id = None\n\n    # Helper to create a group\n    def create_group(name):\n        payload = {\n            \"name\": name,\n            # Add other required fields if any\n        }\n        response = requests.post(f\"{BASE_URL}/groups\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"id\")\n\n    # Helper to delete a group\n    def delete_group(gid):\n        resp = requests.delete(f\"{BASE_URL}/groups/{gid}\", headers=HEADERS, timeout=TIMEOUT)\n        if resp.status_code not in (200, 204):\n            raise Exception(f\"Cleanup failed: could not delete group {gid}\")\n\n    # Helper to add an expense to a group\n    def add_expense(gid, title, amount, paid_by, participants):\n        payload = {\n            \"title\": title,\n            \"amount\": amount,\n            \"paid_by\": paid_by,\n            \"participants\": participants\n        }\n        resp = requests.post(f\"{BASE_URL}/groups/{gid}/expenses\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json().get(\"id\")\n\n    # Helper to get form reset confirmation or check form reset state\n    # Since API does not expose form state, simulate by checking if after submitting a resource,\n    # creating it again with same payload succeeds, assuming stateless API.\n    # Alternatively, check if last submission state is not persisted in error form data.\n    # As API doesn't provide UI form state, we'll verify by submitting multiple times to ensure no residual errors.\n\n    try:\n        # 1. Create group - simulating Submit Group Creation Form\n        unique_group_name = f\"TestGroup-{uuid.uuid4()}\"\n        group_id = create_group(unique_group_name)\n        assert group_id is not None, \"Group creation failed, no id returned.\"\n\n        # Submit same group creation again (simulate form reset allows new submission)\n        group_id_2 = create_group(f\"{unique_group_name}-2\")\n        assert group_id_2 is not None and group_id_2 != group_id, \"Form did not reset properly; duplicate submission failed.\"\n\n        # Clean second group after verification\n        delete_group(group_id_2)\n\n        # 2. Add expense to the created group - simulating Submit Expense Form\n        expense_title = \"Lunch\"\n        expense_amount = 50.0\n        paid_by = \"user@example.com\"  # Simplification: must be a valid member; adjust if needed\n        participants = [\"user@example.com\"]  # Should be group members in real scenario\n\n        expense_id = add_expense(group_id, expense_title, expense_amount, paid_by, participants)\n        assert expense_id is not None, \"Expense creation failed, no id returned.\"\n\n        # Submit another expense with same details to verify form reset after submission\n        expense_id_2 = add_expense(group_id, f\"{expense_title} 2\", expense_amount, paid_by, participants)\n        assert expense_id_2 is not None and expense_id_2 != expense_id, \"Expense form did not reset properly; duplicate submission failed.\"\n\n        # Cleanup second expense if API supports expense deletion (not specified, so skipping)\n        # Assuming no expense deletion endpoint available from PRD\n\n    finally:\n        if expense_id:\n            # No delete endpoint for expenses specified, so skipping\n            pass\n        if group_id:\n            delete_group(group_id)\n\ntest_form_reset_behavior_after_successful_submission()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 88, in <module>\n  File \"<string>\", line 55, in test_form_reset_behavior_after_successful_submission\n  File \"<string>\", line 24, in create_group\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:3000/groups\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-05T09:45:52.659Z",
    "modified": "2025-09-05T09:47:21.018Z"
  }
]
